import fs from 'fs';
import path from 'path';
import replace from '@rollup/plugin-replace';
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import json from '@rollup/plugin-json';
import sucrase from '@rollup/plugin-sucrase';
import typescript from '@rollup/plugin-typescript';
import pkg from './package.json';

const is_publish = !!process.env.PUBLISH;

const ts_plugin = is_publish
  ? typescript({
    include: 'src/**',
    typescript: require('typescript')
  })
  : sucrase({
    transforms: ['typescript']
  });

const external = id => id.startsWith('svelte/');

fs.writeFileSync(`./compiler.d.ts`, `export { compile, parse, preprocess, VERSION } from './types/compiler/index';`);

export default [
  /* runtime */
  {
    input: `src/runtime/index.ts`,
    output: [
      {
        file: `index.mjs`,
        format: 'esm',
        paths: id => id.startsWith('svelte/') && `${id.replace('svelte', '.')}`
      },
      {
        file: `index.js`,
        format: 'cjs',
        paths: id => id.startsWith('svelte/') && `${id.replace('svelte', '.')}`
      }
    ],
    external,
    plugins: [ts_plugin]
  },

  ...fs.readdirSync('src/runtime')
    .filter(dir => fs.statSync(`src/runtime/${dir}`).isDirectory())
    .map(dir => ({
      input: `src/runtime/${dir}/index.ts`,
      output: [
        {
          file: `${dir}/index.mjs`,
          format: 'esm',
          paths: id => id.startsWith('svelte/') && `${id.replace('svelte', '.')}`
        },
        {
          file: `${dir}/index.js`,
          format: 'cjs',
          paths: id => id.startsWith('svelte/') && `${id.replace('svelte', '.')}`
        }
      ],
      external,
      plugins: [
        replace({
          __VERSION__: pkg.version
        }),
        ts_plugin,
        {
          writeBundle(bundle) {
            if (dir === 'internal') {
              const mod = bundle['index.mjs'];
              if (mod) {
                const ssrFileWithPath = path.resolve(dir, `${mod.name}-ssr.mjs`), ssrFileCode = mod.code

                fs.writeFileSync(ssrFileWithPath, ssrFileCode)
                fs.writeFileSync('src/compiler/compile/internal_exports.ts', `// This file is automatically generated\nexport default new Set(${JSON.stringify(mod.exports)});`);
              }
            } else {
              const mod = bundle['index.mjs']

              if (mod) {
                const ssrFileWithPath = path.resolve(dir, `${mod.name}-ssr.mjs`)
                const domFileWithPath = path.resolve(dir, mod.fileName)

                let domFileCode = mod.code, ssrFileCode = mod.code

                domFileCode = domFileCode.replace(/\.\/easing/g, `/js/svelte/easing/index.mjs`)
                domFileCode = domFileCode.replace(/\.\/internal/g, `/js/svelte/internal/index.mjs`)
                domFileCode = domFileCode.replace(/\.\/store/g, `/js/svelte/store/index.mjs`)

                // SSR code loads server side, and needs to be able to 
                ssrFileCode = ssrFileCode.replace(/\.\/easing/g, `../easing/index-ssr.mjs`)
                ssrFileCode = ssrFileCode.replace(/\.\/internal/g, `../internal/index-ssr.mjs`)
                ssrFileCode = ssrFileCode.replace(/\.\/store/g, `../store/index-ssr.mjs`)

                fs.writeFileSync(domFileWithPath, domFileCode)
                fs.writeFileSync(ssrFileWithPath, ssrFileCode)
              }
            }

            fs.writeFileSync(`${dir}/package.json`, JSON.stringify({
              main: './index',
              module: './index.mjs',
              types: './index.d.ts'
            }, null, '  '));

            fs.writeFileSync(`${dir}/index.d.ts`, `export * from '../types/runtime/${dir}/index';`);
          }
        }
      ]
    })),

  /* compiler.js */
  {
    input: 'src/compiler/index.ts',
    plugins: [
      replace({
        __VERSION__: pkg.version
      }),
      resolve(),
      commonjs({
        include: ['node_modules/**']
      }),
      json(),
      ts_plugin
    ],
    output: {
      file: 'compiler.mjs',
      // Use esm format since deno supports this.
      format: 'esm',
      name: 'svelte',
      sourcemap: true,
    },
    // Bundle everything as this needs to be ready for deno to consume.
    external: []
  }
];
